<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[golang pprof 性能分析工具]]></title>
      <url>/2018/01/29/golang-pprof-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<p>性能优化是个永恒的话题，而很多时候我们在作性能优化的时候，往往基于代码上面的直觉，把所有能想到的优化都优化了一遍，不错过任何小的优化点，结果整个代码的逻辑变得极其复杂，而性能上面并没有太大的提升。事实上，性能问题往往集中在某些小点，有时候很小的改动就能有巨大的提升，所以问题的关键是是怎么去找出这些优化点，幸运的是 golang 在设计的时候就考虑了这个问题，原生提供了性能分析的工具，可以很方便地帮我们找到性能瓶颈</p>
<h3 id="pprof-简介"><a href="#pprof-简介" class="headerlink" title="pprof 简介"></a>pprof 简介</h3><p>golang 的性能分析库在 <code>runtime/pprof</code> 里，主要提供下面几个接口</p>
<pre><code class="golang">// 堆栈分析
func WriteHeapProfile(w io.Writer) error
// cpu分析
func StartCPUProfile(w io.Writer) error
func StopCPUProfile()
</code></pre>
<p>使用上面比较简单，只需要将文件指针传给对应的函数即可，性能数据将写入到文件中，然后可以使用 golang 自带的 pprof 工具生成 svg，pdf 的可视化图，然后就可以很直观地从这些图里面看到主要的性能消耗了</p>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><h4 id="首先需要一个程序"><a href="#首先需要一个程序" class="headerlink" title="首先需要一个程序"></a>首先需要一个程序</h4><p>首先需要在你的程序里面注入 pprof 代码，下面是一段示例代码，完整代码在：<a href="https://github.com/hatlonely/hellogolang/blob/master/cmd/pprof_runtime.go" target="_blank" rel="noopener">https://github.com/hatlonely/hellogolang/blob/master/cmd/pprof_runtime.go</a>，这里使用的 <code>PPCmd</code> 方法，是为了方便使用，做的一个简单封装，代码在：<a href="https://github.com/hatlonely/easygolang/blob/master/pprof/pprof.go" target="_blank" rel="noopener">https://github.com/hatlonely/easygolang/blob/master/pprof/pprof.go</a></p>
<pre><code class="golang">func main() {
    go doSomething1()
    go doSomething2()
    go doSomething3()

    if err := pprof.PPCmd(&quot;cpu 10s&quot;); err != nil {
        panic(err)
    }

    if err := pprof.PPCmd(&quot;mem&quot;); err != nil {
        panic(err)
    }
}
</code></pre>
<p>编译，运行上面代码会生成两个 pprof 文件，<code>cpu.pprof.yyyymmddhhmmss</code> 和 <code>mem.pprof.yyyymmddhhmmss</code>，编译运行的方法如下：</p>
<pre><code>cd $GOPATH/src
git clone git@github.com:hatlonely/hellogolang.git
cd hellogolang
glide install
go build cmd/pprof_runtime.go
./pprof_runtime
</code></pre><h4 id="pprof-文件分析"><a href="#pprof-文件分析" class="headerlink" title="pprof 文件分析"></a>pprof 文件分析</h4><p>pprof 文件是二进制的，不是给人读的，需要翻译一下，而 golang 原生就给我们提供了分析工具，直接执行下面命令即可，会生成一张很直观的 svg 图片，直接用 chrome 就可以打开，当然也可以生成别的格式（pdf，png 都可以），可以用 <code>go tool pprof -h</code> 命令查看支持的输出类型</p>
<pre><code>go tool pprof -svg ./pprof_runtime cpu.pprof.201801301415 &gt; cpu.svg
</code></pre><p>注意这个工具依赖于 graphviz 工具，Mac 上可用 <code>brew install graphviz</code>，centos <code>yum install graphviz</code> 即可</p>
<p><img src="/img/stats/pprof_runtime_cpu.png" alt="性能分析图"></p>
<h3 id="http-接口"><a href="#http-接口" class="headerlink" title="http 接口"></a>http 接口</h3><p><code>net/http/pprof</code> 里面对 <code>runtime/pprof</code> 作了一些封装，对外提供了 http 接口，可以直接通过浏览器访问，但是只是一些字符串的结果，没有作可视化，体验并不是很好，用 <code>go tool</code> 访问体验能好一点</p>
<pre><code>go tool pprof http://localhost:3000/debug/pprof/profile
go tool pprof http://localhost:3000/debug/pprof/heap
</code></pre><p>个人感觉这个接口比较鸡肋，首先最大的问题是展示上面并不直观，要是能直接在网页上面可视化地展示可能还真的挺方便的；还有就是需要额外的提供一个 http 的端口，而这个接口还依赖 <code>net/http</code>这就意味着如果你的应用使用的是其他第三方的 http 库，可能还需要解决兼容性的问题；实际上，我再使用这个接口的时候，在服务器压力较大的场景下，会出现访问超时，而这种压力较大情况下的性能可能才是真正的性能瓶颈。</p>
<p>建议在根据的需求，自己封装 <code>runtime/pprof</code> 的接口，当然是用场景比较简单也可以用我上面的封装，然后在服务里面自己提供一个专门的性能分析接口（可能是 gprc，thrift，或者其他的第三方 http 框架）</p>
<h3 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h3><p>除了上面生成的 svg 图，还可以生成火焰图，这是 uber 提供的一个工具，在显示上面可能更直观一些</p>
<p>安装命令如下：</p>
<pre><code>go get github.com/uber/go-torch
git clone git@github.com:brendangregg/FlameGraph.git
export PATH=$PATH:/path/to/FlameGraph
</code></pre><p>使用方法如下：</p>
<pre><code>go-torch --binaryname=./pprof_runtime --binaryinput=cpu.pprof.201801301415
</code></pre><p><img src="/img/stats/pprof_runtime_cpu_torch.svg" alt="性能分析图"></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li>Package pprof: <a href="https://golang.org/pkg/runtime/pprof/" target="_blank" rel="noopener">https://golang.org/pkg/runtime/pprof/</a></li>
<li>Profiling Go Programs: <a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="noopener">https://blog.golang.org/profiling-go-programs</a></li>
<li>Go torch: <a href="https://github.com/uber/go-torch" target="_blank" rel="noopener">https://github.com/uber/go-torch</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> golang </tag>
            
            <tag> 性能 </tag>
            
            <tag> pprof </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[golang json 性能分析]]></title>
      <url>/2018/01/28/golang-json-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>Json 作为一种重要的数据格式，具有良好的可读性以及自描述性，广泛地应用在各种数据传输场景中。Go 语言里面原生支持了这种数据格式的序列化以及反序列化，内部使用反射机制实现，性能有点差，在高度依赖 json 解析的应用里，往往会成为性能瓶颈，好在已有很多第三方库帮我们解决了这个问题，但是这么多库，对于像我这种有选择困难症的人来说，到底要怎么选择呢，下面就给大家来一一分析一下</p>
<h3 id="ffjson"><a href="#ffjson" class="headerlink" title="ffjson"></a>ffjson</h3><pre><code>go get -u github.com/pquerna/ffjson
</code></pre><p>原生的库性能比较差的主要原因是使用了很多反射的机制，为了解决这个问题，ffjson 通过预编译生成代码，类型的判断在预编译阶段已经确定，避免了在运行时的反射</p>
<p>但也因此在编译前需要多一个步骤，需要先生成 ffjson 代码，生成代码只需要执行 <code>ffjson &lt;file.go&gt;</code> 就可以了，其中 <code>file.go</code> 是一个包含 json 结构体定义的 go 文件。注意这里 ffjson 是这个库提供的一个代码生成工具，直接执行上面的 <code>go get</code> 会把这个工具安装在 <code>$GOPATH/bin</code> 目录下，把 <code>$GOPATH/bin</code> 加到 <code>$PATH</code> 环境变量里面，可以全局访问</p>
<p>另外，如果有些结构，不想让 ffjson 生成代码，可以通过增加注释的方式</p>
<pre><code class="golang">// ffjson: skip
type Foo struct {
   Bar string
}

// ffjson: nodecoder
type Foo struct {
   Bar string
}
</code></pre>
<h3 id="easyjson"><a href="#easyjson" class="headerlink" title="easyjson"></a>easyjson</h3><pre><code>go get -u github.com/mailru/easyjson/...
</code></pre><p>easyjson 的思想和 ffjson 是一致的，都是增加一个预编译的过程，预先生成对应结构的序列化反序列化代码，除此之外，easyjson 还放弃了一些原生库里面支持的一些不必要的特性，比如：key 类型声明，key 大小写不敏感等等，以达到更高的性能</p>
<p>生成代码执行 <code>easyjson -all &lt;file.go&gt;</code> 即可，如果不指定 <code>-all</code> 参数，只会对带有 <code>//easyjson:json</code> 的结构生成代码</p>
<pre><code class="golang">//easyjson:json
type A struct {
    Bar string
}
</code></pre>
<h3 id="jsoniter"><a href="#jsoniter" class="headerlink" title="jsoniter"></a>jsoniter</h3><pre><code>go get -u github.com/json-iterator/go
</code></pre><p>这是一个很神奇的库，滴滴开发的，不像 easyjson 和 ffjson 都使用了预编译，而且 100% 兼容原生库，但是性能超级好，也不知道怎么实现的，如果有人知道的话，可以告诉我一下吗？</p>
<blockquote>
<p>2018-1-28日更新，来自官方（@taowen）的回复：<br>没啥神奇的。就是预先缓存了对应struct的decoder实例而已。然后unsafe.Pointer省掉了一些interface{}的开销。还有一些文本解析上的优化</p>
</blockquote>
<p>使用上面，你只要把所有的 </p>
<pre><code>import &quot;encoding/json&quot;
</code></pre><p>替换成</p>
<pre><code>import &quot;github.com/json-iterator/go&quot;

var json = jsoniter.ConfigCompatibleWithStandardLibrary
</code></pre><p>就可以了，其它都不需要动</p>
<h3 id="codec-json"><a href="#codec-json" class="headerlink" title="codec-json"></a>codec-json</h3><pre><code>go get -u github.com/ugorji/go/codec
</code></pre><p>这个库里面其实包含很多内容，json 只是其中的一个功能，比较老，使用起来比较麻烦，性能也不是很好</p>
<h3 id="jsonparser"><a href="#jsonparser" class="headerlink" title="jsonparser"></a>jsonparser</h3><pre><code>go get -u github.com/buger/jsonparser
</code></pre><p>严格来说，这个库不属于 json 序列化的库，只是提供了一些 json 解析的接口，使用的时候需要自己去设置结构里面的值，事实上，每次调用都需要重新解析 json 对象，性能并不是很好</p>
<p>就像名字暗示的那样，这个库只是一个解析库，并没有序列化的接口</p>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>对上面这些 json 库，作了一些性能测试，测试代码在：<a href="https://github.com/hatlonely/hellogolang/blob/master/internal/json/json_benchmark_test.go" target="_blank" rel="noopener">https://github.com/hatlonely/hellogolang/blob/master/internal/json/json_benchmark_test.go</a>，下面是在我的 Macbook 上测试的结果（实际结果和库的版本以及机器环境有关，建议自己再测试一遍）：</p>
<pre><code>BenchmarkMarshalStdJson-4                    1000000          1097 ns/op
BenchmarkMarshalJsonIterator-4               2000000           781 ns/op
BenchmarkMarshalFfjson-4                     2000000           941 ns/op
BenchmarkMarshalEasyjson-4                   3000000           513 ns/op
BenchmarkMarshalCodecJson-4                  1000000          1074 ns/op
BenchmarkMarshalCodecJsonWithBufio-4         1000000          2161 ns/op
BenchmarkUnMarshalStdJson-4                   500000          2512 ns/op
BenchmarkUnMarshalJsonIterator-4             2000000           591 ns/op
BenchmarkUnMarshalFfjson-4                   1000000          1127 ns/op
BenchmarkUnMarshalEasyjson-4                 2000000           608 ns/op
BenchmarkUnMarshalCodecJson-4                  20000        122694 ns/op
BenchmarkUnMarshalCodecJsonWithBufio-4        500000          3417 ns/op
BenchmarkUnMarshalJsonparser-4               2000000           877 ns/op
</code></pre><p><img src="/img/stats/golang_json_performance.png" alt="golang_json_performance"></p>
<p>从上面的结果可以看出来：</p>
<ol>
<li>easyjson 无论是序列化还是反序列化都是最优的，序列化提升了1倍，反序列化提升了3倍</li>
<li>jsoniter 性能也很好，接近于easyjson，关键是没有预编译过程，100%兼容原生库</li>
<li>ffjson 的序列化提升并不明显，反序列化提升了1倍</li>
<li>codecjson 和原生库相比，差不太多，甚至更差</li>
<li>jsonparser 不太适合这样的场景，性能提升并不明显，而且没有反序列化</li>
</ol>
<p><strong>所以综合考虑，建议大家使用 jsoniter，如果追求极致的性能，考虑 easyjson</strong></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li>ffjson: <a href="https://github.com/pquerna/ffjson" target="_blank" rel="noopener">https://github.com/pquerna/ffjson</a></li>
<li>easyjson: <a href="https://github.com/mailru/easyjson" target="_blank" rel="noopener">https://github.com/mailru/easyjson</a></li>
<li>jsoniter: <a href="https://github.com/json-iterator/go" target="_blank" rel="noopener">https://github.com/json-iterator/go</a></li>
<li>jsonparser: <a href="https://github.com/buger/jsonparser" target="_blank" rel="noopener">https://github.com/buger/jsonparser</a></li>
<li>codecjson: <a href="http://ugorji.net/blog/go-codec-primer" target="_blank" rel="noopener">http://ugorji.net/blog/go-codec-primer</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> golang </tag>
            
            <tag> json </tag>
            
            <tag> 性能 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[golang 依赖管理]]></title>
      <url>/2018/01/27/golang-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>依赖管理是一个语言非常重要的特性，很大程度上决定着一个语言的流行程度，流行的语言大多都有非常成熟的依赖管理工具，java 的 maven 和 gradle，javascript 的 npm，python 的 pip，这些工具极大地降低了我们使用第三方库的成本，提高了生产效率，而 c++ 比较奇葩，并没有这样统一的依赖管理工具，大公司好一点，有专门的团队去做这样的工具解决依赖的问题，小公司就只能自己把源码拉下来，放到固定的目录，然后编译成二进制，运气不好的话，还要自己解决各种兼容性的问题，如果有版本更新，这个过程还得重复一遍，第三方库的使用和维护成本之高，让人简直就想放弃……</p>
<p>Golang 是自带依赖管理工具的，直接 <code>go get &lt;packages&gt;</code> 就可以把依赖拉下来，但是这种方式有个缺陷，没有版本控制，你每次拉下来的 <code>package</code> 都是 <code>master</code> 分支上的版本，这样是很危险的，源代码更新可能会有一些对外接口上面的调整，这些调整很有可能就导致你的程序编译通不过，而更致命的是，新的代码引入了一些新的 bug 或者接口语义上的变化会导致你的程序崩溃，所以早期的 gopher 开发了另一个依赖管理工具 <a href="https://github.com/tools/godep" target="_blank" rel="noopener"><code>godep</code></a>解决了版本管理的问题，最近，golang 官方也在开发一个新的依赖管理工具 <a href="https://github.com/golang/dep" target="_blank" rel="noopener"><code>dep</code></a>，但今天我给大家推荐的是 <a href="https://github.com/Masterminds/glide" target="_blank" rel="noopener"><code>glide</code></a> 这款工具，和其他工具相比呢，这款工具支持更多的特性，包括支持依赖的自动分析，指定版本范围，依赖清理等等，而且使用起来也比较简单。这里有一些工具的对比：<a href="https://github.com/Masterminds/glide/wiki/Go-Package-Manager-Comparison" target="_blank" rel="noopener">https://github.com/Masterminds/glide/wiki/Go-Package-Manager-Comparison</a></p>
<p>下面我给大家简单介绍一下 <code>glide</code> 在实际项目中的使用</p>
<h3 id="glide使用"><a href="#glide使用" class="headerlink" title="glide使用"></a>glide使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>Linux</p>
<pre><code>curl https://glide.sh/get | sh
</code></pre><p>Mac</p>
<pre><code>brew install glide
</code></pre><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><pre><code>glide init
</code></pre><p>这个命令会自动分析你代码里面的依赖，然后创建一个 <code>glide.yaml</code> 来描述你当前项目的依赖，生成的这个文件是可以手动编辑的，可以手动修改一些版本之类的信息</p>
<p>提醒一下，这个操作必须在 <code>$GOPATH/src/</code> 的子目录下面，这个和 golang 本身的包管理机制有关，如果没有设置 <code>$GOPATH</code>，记得设置一下 <code>export GOPATH=&lt;directory&gt;</code></p>
<h4 id="依赖下载"><a href="#依赖下载" class="headerlink" title="依赖下载"></a>依赖下载</h4><pre><code>glide update
</code></pre><p>这个命令会下载 <code>glide.yaml</code> 里面的依赖库，并且同样会分析并下载依赖库依赖的其他第三方库，下载的依赖会放到与 <code>glide.yaml</code> 同级的 <code>vendor</code> 目录，同时还会生成一个 <code>glide.lock</code> 文件，这个文件里面描述了当前依赖的版本信息，不要手工编辑这个文件</p>
<p>如果你在中国，这个步骤里面可能会碰到有些 <code>gopkg</code> 的库拉不下来，也不知道为啥要把这个也禁了……如果你碰到这个问题，你可以手动把这些库下载到 <code>${GOROOT}/src/golang.org/x</code> 下面</p>
<pre><code>git clone https://github.com/golang/crypto.git
git clone https://github.com/golang/sys.git
git clone https://github.com/golang/sync.git
git clone https://github.com/golang/text.git
git clone https://github.com/golang/net.git
</code></pre><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre><code>glide get --all-dependencies github.com/foo/bar
</code></pre><p>也可以指定版本</p>
<pre><code>glide get --all-dependencies github.com/foo/bar#^1.2.3
</code></pre><p>除了 <code>github</code> 上的依赖，也可以是其他的平台，比如 <code>gitee</code>，或者自己公司搭建的 gitlab，只要有权限就可以，还有一点需要注意，版本必须是三位数字的版本号，否则可能识别不了</p>
<h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><pre><code>glide install
</code></pre><p>这个命令是在一个已经使用 glide 管理依赖的项目里，需要在新环境下重新安装依赖使用的，这个命令会按照 <code>glide.lock</code> 的信息，把所有的依赖拉取到本地，和 <code>glide update</code> 不同的是，<code>glide update</code> 会来去最新的版本，并且会修改 <code>glide.lock</code>，而 <code>glide install</code> 只下载之前的依赖</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li>glide github: <a href="https://github.com/Masterminds/glide" target="_blank" rel="noopener">https://github.com/Masterminds/glide</a></li>
<li>glide 官网: <a href="https://glide.sh/" target="_blank" rel="noopener">https://glide.sh/</a></li>
<li>glide 文档: <a href="https://glide.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://glide.readthedocs.io/en/latest/</a></li>
<li>go依赖包管理工具对比: <a href="https://ieevee.com/tech/2017/07/10/go-import.html" target="_blank" rel="noopener">https://ieevee.com/tech/2017/07/10/go-import.html</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> golang </tag>
            
            <tag> 依赖管理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[蓄水池算法]]></title>
      <url>/2018/01/26/%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>最近有个需求，需要从不固定大小的数据集中取固定数量的数据作为样本，有个同学提到了蓄水池算法，于是了解了一下。</p>
<p>蓄水池算法，本身是为了解决海量数据的随机抽样问题，在算法领域应用还是挺广泛的，由于数据本身是有权重，又出现了加权蓄水池算法。</p>
<h3 id="蓄水池算法"><a href="#蓄水池算法" class="headerlink" title="蓄水池算法"></a>蓄水池算法</h3><p><strong>问题描述</strong>: 给定一个不固定长度的数据集合 <code>sequence</code>，从中等概率地抽取 <code>k</code> 个元素作为样本返回</p>
<p><strong>问题思路</strong>: 先把样本填满，然后不断往样本里面等概率替换元素</p>
<p><strong>算法实现</strong></p>
<pre><code class="python">def reservior_sampling(sequence, k):
    n = len(sequence)
    if k &gt; n:
        return sequence

    sample = list()
    for i in range(k):
        sample.append(sequence[i])

    for i in range(k, n):
        j = random.randint(0, i)
        if j &gt;= k:
            continue
        sample[j] = sequence[i]

    return sample
</code></pre>
<p>这里需要注意的是往样本里面替换元素的时候，第 <code>i</code> 个元素能被选中用来替换的概率是 <code>k / i + 1</code>，这样就能保证每个元素被选中的机会都是均等的</p>
<h3 id="加权蓄水池算法"><a href="#加权蓄水池算法" class="headerlink" title="加权蓄水池算法"></a>加权蓄水池算法</h3><p><strong>问题描述</strong>: 给定一个不固定长度的非常大的数据集合 <code>sequence</code>，集合中每个元素包含一个权重 <code>weight</code>，按照权重从集合中抽取 <code>k</code> 个元素返回</p>
<p><strong>问题思路</strong>: 和蓄水池算法的思路一样，先把样本填满，然后不断地按照权重替换元素</p>
<p><strong>算法实现</strong></p>
<pre><code class="python">def weighted_reservior_sampling_achao(sequence, k):
    n = len(sequence)
    if k &gt; n:
        return sequence

    wsum = 0
    sample = list()
    for i in range(k):
        sample.append(sequence[i])
        wsum += sequence[i][&#39;weight&#39;] / k

    for i in range(k, n):
        wsum += sequence[i][&#39;weight&#39;] / k
        p = sequence[i][&#39;weight&#39;] / wsum
        j = random.random()
        if j &lt;= p:
            sample[random.randint(0, k-1)] = sequence[i]

    return sample
</code></pre>
<p>这里第 <code>i</code> 个元素被选中用来替换的概率是 <code>sequence[i].weight * k / sum(sequence[0:i+1].weight)</code>，当所有权重都一致的时候，就和蓄水池算法是一致的了。</p>
<p>这里面有个小问题，就是一开始用来填充样本的数据，其实是等概率的，这样会导致，填充样本的数据权重失效，但是这个问题只在数据集合较小（准确地说 <code>k</code> 和 <code>len(sequence)</code> 比较接近）的情况下才会有比较明显的缺陷，在海量数据集的情况下，这种影响是微乎其微的。</p>
<p>完整代码: <a href="https://github.com/hatlonely/algorithm/blob/master/reservoir_sampling.py" target="_blank" rel="noopener">https://github.com/hatlonely/algorithm/blob/master/reservoir_sampling.py</a></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>Reservoir sampling: <a href="https://en.wikipedia.org/wiki/Reservoir_sampling" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Reservoir_sampling</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[golang 几种字符串的连接方式]]></title>
      <url>/2018/01/24/golang-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>最近在做性能优化，有个函数里面的耗时特别长，看里面的操作大多是一些字符串拼接的操作，而字符串拼接在 golang 里面其实有很多种实现。</p>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><h4 id="1-直接使用运算符"><a href="#1-直接使用运算符" class="headerlink" title="1. 直接使用运算符"></a>1. 直接使用运算符</h4><pre><code class="golang">func BenchmarkAddStringWithOperator(b *testing.B) {
    hello := &quot;hello&quot;
    world := &quot;world&quot;
    for i := 0; i &lt; b.N; i++ {
        _ = hello + &quot;,&quot; + world
    }
}
</code></pre>
<p>golang 里面的字符串都是不可变的，每次运算都会产生一个新的字符串，所以会产生很多临时的无用的字符串，不仅没有用，还会给 gc 带来额外的负担，所以性能比较差</p>
<h4 id="2-fmt-Sprintf"><a href="#2-fmt-Sprintf" class="headerlink" title="2. fmt.Sprintf()"></a>2. fmt.Sprintf()</h4><pre><code class="golang">func BenchmarkAddStringWithSprintf(b *testing.B) {
    hello := &quot;hello&quot;
    world := &quot;world&quot;
    for i := 0; i &lt; b.N; i++ {
        _ = fmt.Sprintf(&quot;%s,%s&quot;, hello, world)
    }
}
</code></pre>
<p>内部使用 <code>[]byte</code> 实现，不像直接运算符这种会产生很多临时的字符串，但是内部的逻辑比较复杂，有很多额外的判断，还用到了 <code>interface</code>，所以性能也不是很好</p>
<h4 id="3-strings-Join"><a href="#3-strings-Join" class="headerlink" title="3. strings.Join()"></a>3. strings.Join()</h4><pre><code class="golang">func BenchmarkAddStringWithJoin(b *testing.B) {
    hello := &quot;hello&quot;
    world := &quot;world&quot;
    for i := 0; i &lt; b.N; i++ {
        _ = strings.Join([]string{hello, world}, &quot;,&quot;)
    }
}
</code></pre>
<p>join会先根据字符串数组的内容，计算出一个拼接之后的长度，然后申请对应大小的内存，一个一个字符串填入，在已有一个数组的情况下，这种效率会很高，但是本来没有，去构造这个数据的代价也不小</p>
<h4 id="4-buffer-WriteString"><a href="#4-buffer-WriteString" class="headerlink" title="4. buffer.WriteString()"></a>4. buffer.WriteString()</h4><pre><code class="golang">func BenchmarkAddStringWithBuffer(b *testing.B) {
    hello := &quot;hello&quot;
    world := &quot;world&quot;
    for i := 0; i &lt; 1000; i++ {
        var buffer bytes.Buffer
        buffer.WriteString(hello)
        buffer.WriteString(&quot;,&quot;)
        buffer.WriteString(world)
        _ = buffer.String()
    }
}
</code></pre>
<p>这个比较理想，可以当成可变字符使用，对内存的增长也有优化，如果能预估字符串的长度，还可以用 <code>buffer.Grow()</code> 接口来设置 capacity</p>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><pre><code>BenchmarkAddStringWithOperator-8            50000000             30.3 ns/op
BenchmarkAddStringWithSprintf-8             5000000              261  ns/op
BenchmarkAddStringWithJoin-8                30000000             58.7 ns/op
BenchmarkAddStringWithBuffer-8              2000000000           0.00 ns/op
</code></pre><p>这个是在我的自己 Mac 上面跑的结果，go 版本 <code>go version go1.8 darwin/amd64</code>，这个结果仅供参考，还是要以实际生产环境的值为准，代码在：<a href="https://github.com/hatlonely/hellogolang/blob/master/internal/buildin/string_test.go" target="_blank" rel="noopener">https://github.com/hatlonely/hellogolang/blob/master/internal/buildin/string_test.go</a></p>
<h3 id="主要结论"><a href="#主要结论" class="headerlink" title="主要结论"></a>主要结论</h3><ol>
<li>在已有字符串数组的场合，使用 <code>strings.Join()</code> 能有比较好的性能</li>
<li>在一些性能要求较高的场合，尽量使用 <code>buffer.WriteString()</code> 以获得更好的性能</li>
<li>性能要求不太高的场合，直接使用运算符，代码更简短清晰，能获得比较好的可读性</li>
<li>如果需要拼接的不仅仅是字符串，还有数字之类的其他需求的话，可以考虑 <code>fmt.Sprintf</code></li>
</ol>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>go语言字符串拼接性能分析: <a href="http://herman.asia/efficient-string-concatenation-in-go" target="_blank" rel="noopener">http://herman.asia/efficient-string-concatenation-in-go</a></p>
]]></content>
      
        
        <tags>
            
            <tag> golang </tag>
            
            <tag> string </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[第一次写JD]]></title>
      <url>/2018/01/22/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%99JD/</url>
      <content type="html"><![CDATA[<p>有个同学（同事+同学+室友+基友）要离职了（离职的原因，因为爱情，让我们一起祝福他们吧），缺一个人，老大说，你要找个什么样的人，你自己来写JD吧。</p>
<p>JD（job description）翻译过来工作岗位描述，先来看下我写的JD吧。</p>
<blockquote>
<p><strong>职位诱惑</strong></p>
<blockquote>
<p>双倍于BAT的成长速度</p>
</blockquote>
<p><strong>职位职责</strong></p>
<blockquote>
<ol>
<li>后端工程架构的设计与实现</li>
</ol>
</blockquote>
<p><strong>职位要求</strong></p>
<blockquote>
<ol>
<li>敬畏技术，追求卓越</li>
<li>精通数据结构与算法</li>
<li>至少对一门语言有较深入的研究，至少对一项技术有自己的理解</li>
<li>良好的学习能力，良好的沟通表达能力</li>
<li>爱技术，爱折腾，有代码洁癖、博客、github者优先</li>
<li>不接受非本人制作的简历</li>
</ol>
</blockquote>
<p><strong>工作地点</strong></p>
<blockquote>
<p>北京-望京-金辉大厦</p>
</blockquote>
</blockquote>
<p>职位诱惑，我看到拉勾网上好多写的都是，什么半年调薪，季度奖金，公司福利好啊之类的，好像现在所有互联网公司都这样说，但是做得怎么样可能就差距很大了，这些东西都的可解释性很强，比如奖金，人家王者荣耀发几十个月的年终奖，你发一个月还得乘个系数；人家一年调了三次薪水，你一年调了一次，涨了5%；公司说免费的三餐，如果你想变瘦的话，确实还挺适合你的。所以这些东西真的有什么诱惑力吗？其实最实际的还是最后 offer 里面里面的实际薪资，你要直接告诉我，这个职位月薪 50K，那确实会有一些诱惑力。</p>
<p>那除了自己的利益，还有什么诱惑呢？我觉得还有两点，个人的成长以及公司的愿景。我自己就是一个很关注自身成长的人，毕业之后去百度，包括后来离开，来到mobvista，每次选择都把个人成长放到首要的位置，因为我知道，人生很短，而技术这条路很长，并没有那么多时间能让我去挥霍，而这个过程中，你遇到的人其实很关键，俗话说『听君一席话，胜读十年书』，有些东西，你要靠自己去摸索，真的会走很多弯路，甚至完全就走偏了，感谢我遇到的每个人，感谢你们带给我的成长。而公司愿景，可能听起来很虚，但是实际上对某些人来说，特别是不甘于平庸的人来说，是非常吸引人的，最近我时常在想一个词，『社会责任感』，近二三十年，互联网的飞速发展，彻底地改变了人们的生活，而我现在，深处在这样一个时代的潮流之中，像我这样一个人，到底能为这个社会创造怎样的价值？</p>
<p>所以我写下了双倍于BAT的成长速度，很虚，谁也不知道双倍是多快，甚至不知道有没有更快，但是我只是想让你知道，我在关注这件事情，我会尽我所能地去做到这件事情，这是我的责任，也是我对你的承诺。</p>
<p>职位职责，我看很多都会写现在具体做的事情，还会写一些什么问题排查啊，性能优化之类的事情，这些事情，我不写难道你不知道吗，而我写了，难道就只有这些吗？所以我把这些内容都省略了，只有一条，后端架构的设计与实现，你要知道，你来做的是后端，不是前端，也不是ios或者Android，另外你要做的事情，不仅仅包含系统的实现，同样包含系统的设计。</p>
<p>职位要求，我重点写了一下，主要为了节约一些时间，要知道，面试其实也是一件耗时且无趣的事情，非诚勿扰，谢谢！</p>
<p>第一点，『敬畏技术，追求卓越』，这个其实是公司技术部门，经历一些惨痛教训之后喊出来的口号，我很开心公司能有这样转变，特别是最近超哥（蔡超，前亚马逊中国研发中心首席架构师）的加入，能明显的感觉到技术文化的一些变化。</p>
<p>数据结构与算法，面试过很多七八年工作经验的人，很少人有能让我满意的（其实离满意差很远，简直难以相信），反而是一些年轻些的朋友，能做得比较好，很多人反驳我说，工作时间长了，这些东西经常不用，就忘了，也可以理解，要求不要太高，差不多行了，确实我也做过一些让步，放低一些要求。但是不得不说这是一种悲哀，数据结构与算法，可以说是整个计算机行业的基础，任何的程序都是构建在这样的基础之上，你告诉我说，随着工作经验的增长，这些基础你忘记了，那我会怀疑我们真的是在同一个行业吗？事实上，如果你不熟悉基础，那你的很多实现就会变得很麻烦，很难理解，耗时很长，而且问题很多。相比之下，国外的公司就很看重这个，好几轮的面试全都是算法，不把 <a href="https://leetcode.com/" target="_blank" rel="noopener"><code>leetcode</code></a> 刷个两三遍，都不好意思去找工作。与其说工作时间长了忘了，不如说是被惯坏了，因为国内这种浮躁的氛围，反正干这行，就肯定能找到工作，此处不留爷自有留爷处，何必花那些时间去折腾那些基础的东西，捞钱才最重要，过个一两年，干不下去了，再换个公司，还能涨比钱，整个行业的整体人才素质，就是这样被拉低了……所以，别和我说你再哪哪哪干过多少年，管过多少个人，在我这不好使，麻烦让我看到，现在此刻你有能力解决这个算法问题。</p>
<p>第三点，至少对一门语言有较深入的研究，至少对一项技术有自己的理解。这个其实挺难的，我看很多简历上都写着，有七八年的 c++ 使用经验，然后竟然不知道标准库里面的排序怎么用，不知道 <code>vector</code> 可以设置 <code>capcity</code>，你……让我情何以堪……，最近在用 golang，虽然用的时间不长，但自以为用得还挺6，但是超哥的加入，让我发现自己对 golang 其实一无所知，单元测试框架，pprof 性能分析，堆栈内存分配机制，锁的性能开销，gc 以及协程调度开销等等，让我开始反思自己到底学了些什么……这里我对语言和技术的定义都比较宽泛，没有特别指定何种语言，哪种技术，因为我觉得技术这东西的思想是相通的，你能掌握好一种，就能很快掌握别的，但是前提是你得掌握至少一种，我看重的是你的学习能力，看过某个牛人说过，『我不是啥都懂，我只是学得快』，如果你一种都不精通，很难让我相信你有很强的学习能力。</p>
<p>第四点，我又强调了一下学习能力，因为这个能力真的很重要，这个行业发展那么迅速，没有很强的学习能力，一定会成为团队的负担。另外沟通表达能力，这个被我之前被我忽视的能力，在最近的一年里，让我有非常深切的体会。这个能力包含两个方面，一个是如何快速准确理解别人给你的信息，还一个是如何准确地传达你想要表达的信息。毕竟这是一个高度社会化的行业，任何事情都是人与人合作的结果，中间任何一点理解上面的偏差都有可能造成非常严重的后果。</p>
<p>第五点，可以说是我个人的一个价值观吧，我从心里欣赏这样的人，希望与这样的人相处，和他们一起共事。最近认识了一些新朋友，都还是学生，已经能在 github 上写出 star 2k+的项目了，在看看自己，感觉很是惭愧……</p>
<p>第六点，特别注明了一下，不接受非本人制作的简历，现在这种找工作的 App 做得都很方便，你在上面随便填写东西，然后就会有猎头找到你，帮你找工作，然后还能自动帮你生成简历，我只想说这种简历实在是太low。简历其实可以看出很多东西，排版组织其实可以看出来你个人的一些性格，对项目的描述，也能看出来你的一些表达能力，当然还有很多细节啦，这种自动生成的东西完全没有太多的参考价值。如果你觉得这个东西很方便，能帮你节约时间的话，那我多少也能看出来，你是一个对自己不负责任，得过且过的人，对自己尚且如此，工作亦然。所以，对自己好一点，做个精致的简历吧！</p>
<p>最后祝大家都能找到自己理想的工作，如果找不到，可以来投奔我😏</p>
]]></content>
      
        
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[与vim的一段往事]]></title>
      <url>/2018/01/21/%E4%B8%8Evim%E7%9A%84%E4%B8%80%E6%AE%B5%E5%BE%80%E4%BA%8B/</url>
      <content type="html"><![CDATA[<p>这就要从大学里面学c语言说起了，那个时候我们还在用古老的 visual c++ 6.0（满满的回忆有木有……），不过我唯一的印象只剩下了，嗯，这个东西真的很丑很难用，不过还好，不久就有了 visual studio 2010，好看是好看了，但是好像卡得不行，也不知道是 windows 的锅呢，还是 vs 的锅呢，还是我电脑配置太低，anyway，这些都不太重要，反正那个时候对 IDE 没有什么好感，再加上英语也不太好，那些软件又都是英文，就更不想用了……</p>
<p>后来呢，进了一个实验室，发现大家都在一个黑白的终端下面写代码，所有的操作都通过键盘完成，完全不用鼠标，当时我都惊呆了，这和电视里面演的黑客不是一模一样么，瞬间觉得那些 IDE 简直 low 爆了，真正厉害的黑客是不用 IDE 的（当时天真的想法……）。Vim —— Text editor of the Gods，正是我想要的。</p>
<p>于是开始读vim的书，查相关的资料，记各种快捷键，装各种插件，折腾我的 vimrc。为了用上更纯粹的 vim，我装了双系统；为我的 chrome 装了 vim 插件；在 win 系统下用 vim 整了一套开发环境。远离鼠标！拒绝 IDE！很快我就在 vim 的使用上面小有成就。</p>
<p>然而一直有一个问题我没有解决，但是我相信和其他问题一样，很快就能找到答案。这个问题就是，我想做到像 IDE 那样的智能代码提示，以及函数的调用以及声明的跳转。我查了好多资料，尝试了很多方案，最后好不容易是有提示了，但是提示的内容只是这个文件中出现的其他标识符，也有点用，但是和我想要的还差很远；然后又继续尝试，功夫不负有心人，终于找到了标准库的代码提示，然而只能提示标准库，我自己写的类并没有用；然后我又继续尝试，然后时间一天天过去，并没有什么进展，渐渐地也就没有太大的兴趣了，现在这么用也挺好，真正的黑客是不依赖 IDE 的提示的。而函数跳转的那个问题也类似，一直也没有找到一个完美的解决方案。</p>
<p>后来开始学 java 了，作为 vim 的脑残粉，肯定是要用 vim 来写 java 的，没有代码提示，没有函数跳转，没有编译调试环境，无形之中给自己增加了好多难度，但是老师可不会等我把这些都整明白了再教，没办法，最终还是很不情愿地随了大流，用了 eclipse。</p>
<p>后来终于毕业了，看到公司里大家都在用 vim，我就放心了，这里这么多大牛，困扰我好几年的问题应该能很快就解决了吧。然而……，我发现，我竟然是这里面用 vim 用得最熟练……，也不知道是该高兴呢，还是该忧伤……</p>
<p>省吃俭用的工资终于够买 Mac，第一件事情，就是配置好 vim。然后果断放弃 windows，开始折腾新的 Mac。发现 Mac 上自带的 xcode 做得还挺好看的，关键是还能写 c++，然后就试了试，感觉还挺爽，关键是有错误直接就能看出来，不像之前用 vim 那样写了一大堆，尝试编译一下，跳出几十个错误；智能提示也很友好，好多之前没用过的函数被提示出来才知道，原来还有这么方便的函数，之前我都用别的方式自己实现了一下……；按住 <code>cmd</code> 键就能很方便地跳转到函数实现的地方，再也不用从一堆文件里面去猜，这个函数可能是在哪里实现的了。尝到甜头之后，开始尝试把公司的项目往 xcode 上面迁，结果开发效率有了极大的提升，而更关键的是写代码变成了一件愉快的事情。</p>
<p>现在，基本我所有的代码都用不同的 IDE（xcode, goland, ideal, pycharm, sublime text 3, webstorm）开发完成。而曾经那么迷恋的 vim，有时候在服务器上写一些临时的脚本，也还是会用一用的。</p>
<p>讲真的，鼠标和 IDE 都是非常伟大的发明，把人从繁复重复无聊的工作中解放出来，让人的精力集中在更具创造力的地方，极大提高了生产效率，推动了整个行业的快速发展。而 vim 作为上一个时代的效率的代表，也曾经那么光彩照人，也是时候功成身退了。</p>
<p>科技在进步，时代在向前，虽然我也是一个怀旧的人，但也不想被潮流甩开太远。</p>
]]></content>
      
        
        <tags>
            
            <tag> vim </tag>
            
            <tag> ide </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[谈谈注释]]></title>
      <url>/2018/01/19/%E8%B0%88%E8%B0%88%E6%B3%A8%E9%87%8A/</url>
      <content type="html"><![CDATA[<p>大家肯定都有写过注释，注释这个东西不同于代码，与程序逻辑的正确性没有直接的关系，所以每个人可能都有自己的风格，每个人对哪里应该写注释，注释应该写成什么样子可能都有自己的理解。</p>
<p>我个人对注释的理解经历了四个阶段。</p>
<p>第一个阶段，完全不写注释，这个阶段还处在代码逻辑的实现上面，花大量的时间去调试，修改代码，根本就无暇顾及到注释这个事情。过了一段时间后，发现之前写的又臭又长的代码完全看不明白了，才意识到注释的重要性，于是开始慢慢进入了第二个阶段。</p>
<p>第二个阶段，哪哪都是注释，每个文件，每个类，每个函数，设置每个分支，每个变量，都有一个注释来说明，就怕漏掉某个小细节然后就看不懂了。后来又发现了一个叫做文档注释的东西（doxygen），这个东西不要太酷，可以根据你的写的注释直接生成文档，于是到处都是文档注释，每个文件里面都有一段简介，而简介里面最重要的内容可能就是 <code>@author: hatlonely</code>，生怕别人不知道这些这么low的代码是你写出来的🤦‍♀️，每个函数参数，函数参数的返回值等等，也都有详尽的注释，注释的长度已经远远超过了代码的长度。看起来好像妈妈再也不用担心我看不懂之前写的代码了，然而，一段时间当我重新读到add这个函数的注释的时候，我发现这些信息对我来说好像并没有用，这段代码已经足够的清晰简单，甚至比注释更容易读懂，那这个注释在这里存在的意义又是什么呢，仅仅是为了生成文档注释吗？而更大的问题可能是，如果我要新增一个函数，<code>add3(int a, int b, int c)</code> 我不得不按照之前的文档注释格式写一大堆的注释……注释的维护也是一个大问题，每次逻辑的变更，都需要去改对应的注释，如果忘记修改，注释和代码逻辑的不一致会让人更加困惑。于是注释的维护变成了一件非常无聊的事情，大大地降低了编程体验，而另一方面冗长繁复的注释也降低了代码的阅读体验。</p>
<pre><code class="c++">// @file: 谈谈注释.md
// @date: 2018-01-19 14:00
// @author: hatlonely
// @brief: 一些对注释的理解

// @brief: 求两个数的和 
// @param a 加数
// @param b 被加数
// @return 和
int add(int a, int b) {
    return a + b;
}
</code></pre>
<p>第三个阶段，代码即注释。突然有一天，看到一个观点，代码是一种艺术，本身就是美，就像是诗歌，你见过一首诗歌里面插入了很多注释吗？注释不是对代码的翻译，而绝大多数时候，你在考虑用一个注释解释一个变量的时候，往往可以通过一个好的变量名来避免这个注释，同样，当你要注释某段逻辑的时候，也往往可以通过优化这段逻辑结构，使用一些可读性更强的变量来描述某些过程。于是我去掉了所有的注释，开始编写可读性更强的代码，开始纠结每一个普通的小变量的命名，开始站在普通人的角度去思考代码的逻辑，让代码更贴近自然语言，把让没有任何计算机基础的人都能读懂我的代码作为目标。于是现在代码看起来清爽了不少，代码本该如此简单。但是我满意了吗？并没有。</p>
<p>第四个阶段，必要的注释。毕竟代码不是诗歌，如果没有当时的文化背景以及别人的解读，大部分是诗歌普通人应该也是读不懂的吧。代码逻辑是由特定的场景决定，同一份代码在不同的场景下面也可能是完全不同的含义，所以为什么会是这样一个逻辑，是这个场景下特定的背景所决定的，而代码本身并不能包含这些背景信息。比如下面这段代码，关于ios过滤的这段逻辑，是因为目前的业务上暂时还没有这个需求决定的，这里的注释给了我们一些额外的信息，对我们理解这段逻辑有很大的帮助，如果没有这段注释，一个月后，你可能也忘记了为什么要有ios这样一个特殊的逻辑，不敢动也不知道，久而久之这些代码就成了谜一样的存在。嗯，看起来很优雅，现在我满意了！</p>
<pre><code class="golang">func checkDeviceType(info DeviceInfo, deviceTypeSet map[int32]struct{}) bool {
    // ios的设备类型不想android那么多，暂时还没有定向需求
    if info.platform != &quot;ios&quot; {
        return true
    }

    if _, ok := deviceTypeSet[info.deviceType]; ok {
        return true
    }
    return false
}
</code></pre>
<p>下一个阶段是什么呢？是时候提高一下自己的表述能力了🤣🤣。</p>
]]></content>
      
        
        <tags>
            
            <tag> 注释 </tag>
            
            <tag> 编码风格 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[golang slice 性能分析]]></title>
      <url>/2018/01/18/golang-slice-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>golang 在 gc 这块的做得比较弱，频繁地申请和释放内存会消耗很多的资源。另外 slice 使用数组实现，有一个容量和长度的问题，当 slice 的容量用完再继续添加元素时需要扩容，而这个扩容会把申请新的空间，把老的内容复制到新的空间，这是一个非常耗时的操作。有两种方式可以减少这个问题带来的性能开销：</p>
<ol>
<li>在 slice 初始化的时候设置 capacity（但更多的时候我们可能并不知道 capacity 的大小）</li>
<li>复用 slice</li>
</ol>
<p>下面就针对这两个优化设计了如下的benchmark，代码在: <a href="https://github.com/hatlonely/hellogolang/blob/master/internal/buildin/slice_test.go" target="_blank" rel="noopener">https://github.com/hatlonely/hellogolang/blob/master/internal/buildin/slice_test.go</a></p>
<pre><code>BenchmarkAppendWithoutCapacity-8                     100      21442390 ns/op
BenchmarkAppendWithCapLessLen10th-8                  100      18579700 ns/op
BenchmarkAppendWithCapLessLen3th-8                   100      13867060 ns/op
BenchmarkAppendWithCapEqualLen-8                     200       6287940 ns/op
BenchmarkAppendWithCapGreaterLen10th-8               100      18692880 ns/op
BenchmarkAppendWithoutCapacityReuse-8                300       5014320 ns/op
BenchmarkAppendWithCapEqualLenReuse-8                300       4821420 ns/op
BenchmarkAppendWithCapGreaterLen10thReuse-8          300       4903230 ns/op
</code></pre><h3 id="主要结论"><a href="#主要结论" class="headerlink" title="主要结论"></a>主要结论</h3><ol>
<li>在已知 capacity 的情况下，直接设置 capacity 减少内存的重新分配，有效提高性能</li>
<li>capacity &lt; length，capacity 越接近 length，性能越好</li>
<li>capacity &gt; lenght，如果太大，反而会造成性能下降，这里当 capacity &gt; 10 * length时，与不设置 capacity 的性能差不太多</li>
<li>多次使用复用同一块内存能有效提高性能</li>
</ol>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><pre><code class="go">func BenchmarkAppendWithoutCapacity(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        var arr []int
        for i := 0; i &lt; N; i++ {
            arr = append(arr, i)
        }
    }
}

func BenchmarkAppendWithCapLessLen10th(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        arr := make([]int, 0, N/10)
        for i := 0; i &lt; N; i++ {
            arr = append(arr, i)
        }
    }
}

func BenchmarkAppendWithCapLessLen3th(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        arr := make([]int, 0, N/3)
        for i := 0; i &lt; N; i++ {
            arr = append(arr, i)
        }
    }
}

func BenchmarkAppendWithCapEqualLen(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        arr := make([]int, 0, N)
        for i := 0; i &lt; N; i++ {
            arr = append(arr, i)
        }
    }
}

func BenchmarkAppendWithCapGreaterLen10th(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        arr := make([]int, 0, N*10)
        for i := 0; i &lt; N; i++ {
            arr = append(arr, i)
        }
    }
}

func BenchmarkAppendWithoutCapacityReuse(b *testing.B) {
    var arr []int
    for i := 0; i &lt; b.N; i++ {
        arr = arr[:0]
        for i := 0; i &lt; N; i++ {
            arr = append(arr, i)
        }
    }
}

func BenchmarkAppendWithCapEqualLenReuse(b *testing.B) {
    arr := make([]int, N)
    for i := 0; i &lt; b.N; i++ {
        arr = arr[:0]
        for i := 0; i &lt; N; i++ {
            arr = append(arr, i)
        }
    }
}

func BenchmarkAppendWithCapGreaterLen10thReuse(b *testing.B) {
    arr := make([]int, N*10)
    for i := 0; i &lt; b.N; i++ {
        arr = arr[:0]
        for i := 0; i &lt; N; i++ {
            arr = append(arr, i)
        }
    }
}
</code></pre>
]]></content>
      
        
        <tags>
            
            <tag> golang </tag>
            
            <tag> slice </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[golang 开发目录结构]]></title>
      <url>/2018/01/16/golang-%E5%BC%80%E5%8F%91%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>在实际的项目中发现大家的目录结构都比较凌乱，基本每个人都有每个人的风格，一个项目在不断地变大，一些新的文件或目录又不断地被添加进来，从这里面去找到自己需要的信息的成本越来越高，一个统一的通用的目录结构非常有必要。</p>
<p>以下内容来自于github上的这个项目（<a href="https://github.com/golang-standards/project-layout" target="_blank" rel="noopener">https://github.com/golang-standards/project-layout</a>）</p>
<h3 id="cmd"><a href="#cmd" class="headerlink" title="/cmd"></a><code>/cmd</code></h3><p>main函数文件（比如 <code>/cmd/myapp.go</code>）目录，这个目录下面，每个文件在编译之后都会生成一个可执行的文件。</p>
<p>不要把很多的代码放到这个目录下面，这里面的代码尽可能简单。</p>
<h3 id="internal"><a href="#internal" class="headerlink" title="/internal"></a><code>/internal</code></h3><p>应用程序的封装的代码，某个应用私有的代码放到 <code>/internal/myapp/</code> 目录下，多个应用通用的公共的代码，放到 <code>/internal/common</code> 之类的目录。</p>
<h3 id="pkg"><a href="#pkg" class="headerlink" title="/pkg"></a><code>/pkg</code></h3><p>一些通用的可以被其他项目所使用的代码，放到这个目录下面</p>
<h3 id="vendor"><a href="#vendor" class="headerlink" title="/vendor"></a><code>/vendor</code></h3><p>项目依赖的其他第三方库，使用 <a href="https://github.com/Masterminds/glide" target="_blank" rel="noopener"><code>glide</code></a> 工具来管理依赖</p>
<h3 id="api"><a href="#api" class="headerlink" title="/api"></a><code>/api</code></h3><p>协议文件，<code>Swagger/thrift/protobuf</code> 等</p>
<h3 id="web"><a href="#web" class="headerlink" title="/web"></a><code>/web</code></h3><p>web服务所需要的静态文件</p>
<h3 id="configs"><a href="#configs" class="headerlink" title="/configs"></a><code>/configs</code></h3><p>配置文件</p>
<h3 id="init"><a href="#init" class="headerlink" title="/init"></a><code>/init</code></h3><p>服务启停脚本</p>
<h3 id="scripts"><a href="#scripts" class="headerlink" title="/scripts"></a><code>/scripts</code></h3><p>其他一些脚本，编译、安装、测试、分析等等</p>
<h3 id="build"><a href="#build" class="headerlink" title="/build"></a><code>/build</code></h3><p>持续集成目录</p>
<p>云 (AMI), 容器 (Docker), 操作系统 (deb, rpm, pkg)等的包配置和脚本放到 <code>/build/package/</code> 目录</p>
<h3 id="deployments"><a href="#deployments" class="headerlink" title="/deployments"></a><code>/deployments</code></h3><p>部署相关的配置文件和模板</p>
<h3 id="test"><a href="#test" class="headerlink" title="/test"></a><code>/test</code></h3><p>其他测试目录，功能测试，性能测试等</p>
<h3 id="docs"><a href="#docs" class="headerlink" title="/docs"></a><code>/docs</code></h3><p>设计文档</p>
<h3 id="tools"><a href="#tools" class="headerlink" title="/tools"></a><code>/tools</code></h3><p>常用的工具和脚本，可以引用 <code>/internal</code> 或者 <code>/pkg</code> 里面的库</p>
<h3 id="examples"><a href="#examples" class="headerlink" title="/examples"></a><code>/examples</code></h3><p>应用程序或者公共库使用的一些例子</p>
<h3 id="assets"><a href="#assets" class="headerlink" title="/assets"></a><code>/assets</code></h3><p>其他一些依赖的静态资源</p>
]]></content>
      
        
        <tags>
            
            <tag> golang </tag>
            
            <tag> 开发 </tag>
            
            <tag> 目录结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《microservice & serverless》by 蔡超的一点感想]]></title>
      <url>/2018/01/12/%E3%80%8Amicroservice-&amp;-serverless%E3%80%8Bby-%E8%94%A1%E8%B6%85%E7%9A%84%E4%B8%80%E7%82%B9%E6%84%9F%E6%83%B3/</url>
      <content type="html"><![CDATA[<p>超哥是来自Amazon的顶级的架构师，经历了Amazon整个向微服务架构迁移的过程，以及向serverless的演化过程，有着极其丰富的经验，年过40，一直站在技术的最前沿，始终保持对技术的执着追求和热情，是名副其实的技术大牛，能与之一起工作，荣幸之至！今天超哥给我们分享的主题《microservice &amp; serverless》，是超哥实际工作经验的一些分享，也为公司架构的演化提供了新的思路和指导。</p>
<p>microservice（微服务）这个可能是这些年最火的一种架构设计了，频繁地出现在各种技术大会上，各大互联网巨头纷纷向这种架构演化，很多小的互联网公司也往这些概念上去靠，大有一种不做微服务就要落伍的趋势。事实上，很多对于微服务的理解比较粗浅，盲目的微服务化甚至会带来更多的负面影响。</p>
<p>目前Amazon内部运行着超过2w过微服务，但是这些微服务并不是凭空产生的，在这之前，运行的服务都是超大的单体服务，但是随着业务的发展，这种服务在整个研发的pipeline（设计→研发→编译→测试→发布→部署→运维）中都出现了一些问题。设计阶段，老的单体服务会给我们带来一些技术限制，比如有些技术只有python语言的实现，但是我们的服务使用java开发，这样我们不得不拿出一个更复杂的设计去解决类似的问题；研发阶段，随着开发人数越来越多，代码冲突的问题越来越多，我们不得不花更多的时间去做这种无趣又没有什么意义的事情；编译阶段，越来越多的依赖很容易造成版本冲突，不同的版本也会引发兼容性的问题，而这种问题如果在运行时才暴露出来可能会造成严重业务影响；部署阶段，很多的特性打包在一起发布，特性越多，出问题的概率也就越大；而最致命的是运维阶段没有回滚方案，一次上线中可能包含很多的特性，而其中任何一条特性的bug就需要回滚，然后可能有些特性需要变更数据格式，新特性能向前兼容老的数据格式，但是回滚后却无法处理新的数据格式，因此无法回滚……就是在这样的背景下，Amazon开始朝微服务的架构演化。</p>
<p>微服务摆脱了单体服务技术的束缚，可以自由地根据业务的特点，选择最适合的技术去实现自己的服务；将一个大的开发流程拆成了很多个小的独立的开发流程，彼此之间不在相互依赖，大大缩短了项目周期；代码冲突的问题也得到了很好的改善；每次发布的特性很少，每天都能发布，而且能做到快速回滚。真正做到，持续集成，持续交付，敏捷开发。</p>
<p>微服务架构同时也带来了一些新的问题。相比与单体服务，微服务的架构数据的传输依赖于rpc的调用，这个调用会带来一些额外的网络耗时，这种耗时往往需要业务上面去考虑是否能容忍，这种rpc的调用收到网络环境的影响，失败是很正常事情，因此需要失败重试机制，于是代码里面到处都充斥着失败重试的冗余代码，影响代码的可读性，更糟糕的是会有雪崩效应，当某个底层服务出现问题时，比如响应时间过长，或者无法访问，这种影响会层层传递到上层，最终导致整个业务系统挂掉；在测试上面也会变得更加困难，之前都在一个实例里面，现在一个服务依赖很多其他的微服务，测试的时候都需要去mock，日志也会分布在不同的服务下面，问题排查比较困难；此外，数据分布在不同的微服务上，在数据一致性上也会有些问题。所以在进行微服务设计的时候也要特别注意这些额外的负面影响，封装重试逻辑，引入熔断和限流机制，统一的日志收集方式。</p>
<p>serverless（无服务器）架构可能是为了让devOps从繁复的运维工作中解放出来的全新架构，最大的特点是整个系统基于AWS提供的各种服务，能够做到自动的拓展以及按流量计费，不再需要人力去维护，大大提高了效率，同时按真实流量的计费对成本也有可能会有优化。而Fass架构，把业务需求封装在一个函数内部，开发人员只需要关注自己的业务逻辑，然后通过网页提交就能完成上线。我在想，当这些技术真正成熟和普及的时候，可能每个普通人，随便花点时间学点python，也能做出一个的服务，而那个时候，我的价值又是什么！？</p>
]]></content>
      
        
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 无服务架构 </tag>
            
            <tag> serverless </tag>
            
            <tag> microservice </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
