<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[第一次写JD]]></title>
      <url>/2018/01/22/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%99JD/</url>
      <content type="html"><![CDATA[<p>有个同学（同事+同学+室友+基友）要离职了（离职的原因，因为爱情，让我们一起祝福他们吧），缺一个人，老大说，你要找个什么样的人，你自己来写JD吧。</p>
<p>JD（job description）翻译过来工作岗位描述，先来看下我写的JD吧。</p>
<blockquote>
<p><strong>职位诱惑</strong></p>
<blockquote>
<p>双倍于BAT的成长速度</p>
</blockquote>
<p><strong>职位职责</strong></p>
<blockquote>
<ol>
<li>后端工程架构的设计与实现</li>
</ol>
</blockquote>
<p><strong>职位要求</strong></p>
<blockquote>
<ol>
<li>敬畏技术，追求卓越</li>
<li>精通数据结构与算法</li>
<li>至少对一门语言有较深入的研究，至少对一项技术有自己的理解</li>
<li>良好的学习能力，良好的沟通表达能力</li>
<li>爱技术，爱折腾，有代码洁癖、博客、github者优先</li>
<li>不接受非本人制作的简历</li>
</ol>
</blockquote>
<p><strong>工作地点</strong></p>
<blockquote>
<p>北京-望京-金辉大厦</p>
</blockquote>
</blockquote>
<p>职位诱惑，我看到拉勾网上好多写的都是，什么半年调薪，季度奖金，公司福利好啊之类的，好像现在所有互联网公司都这样说，但是做得怎么样可能就差距很大了，这些东西都的可解释性很强，比如奖金，人家王者荣耀发几十个月的年终奖，你发一个月还得乘个系数；人家一年调了三次薪水，你一年调了一次，涨了5%；公司说免费的三餐，如果你想变瘦的话，确实还挺适合你的。所以这些东西真的有什么诱惑力吗？其实最实际的还是最后 offer 里面里面的实际薪资，你要直接告诉我，这个职位月薪 50K，那确实会有一些诱惑力。</p>
<p>那除了自己的利益，还有什么诱惑呢？我觉得还有两点，个人的成长以及公司的愿景。我自己就是一个很关注自身成长的人，毕业之后去百度，包括后来离开，来到mobvista，每次选择都把个人成长放到首要的位置，因为我知道，人生很短，而技术这条路很长，并没有那么多时间能让我去挥霍，而这个过程中，你遇到的人其实很关键，俗话说『听君一席话，胜读十年书』，有些东西，你要靠自己去摸索，真的会走很多弯路，甚至完全就走偏了，感谢我遇到的每个人，感谢你们带给我的成长。而公司愿景，可能听起来很虚，但是实际上对某些人来说，特别是不甘于平庸的人来说，是非常吸引人的，最近我时常在想一个词，『社会责任感』，近二三十年，互联网的飞速发展，彻底地改变了人们的生活，而我现在，深处在这样一个时代的潮流之中，像我这样一个人，到底能为这个社会创造怎样的价值？</p>
<p>所以我写下了双倍于BAT的成长速度，很虚，谁也不知道双倍是多快，甚至不知道有没有更快，但是我只是想让你知道，我在关注这件事情，我会尽我所能地去做到这件事情，这是我的责任，也是我对你的承诺。</p>
<p>职位职责，我看很多都会写现在具体做的事情，还会写一些什么问题排查啊，性能优化之类的事情，这些事情，我不写难道你不知道吗，而我写了，难道就只有这些吗？所以我把这些内容都省略了，只有一条，后端架构的设计与实现，你要知道，你来做的是后端，不是前端，也不是ios或者Android，另外你要做的事情，不仅仅包含系统的实现，同样包含系统的设计。</p>
<p>职位要求，我重点写了一下，主要为了节约一些时间，要知道，面试其实也是一件耗时且无趣的事情，非诚勿扰，谢谢！</p>
<p>第一点，『敬畏技术，追求卓越』，这个其实是公司技术部门，经历一些惨痛教训之后喊出来的口号，我很开心公司能有这样转变，特别是最近超哥（蔡超，前亚马逊中国研发中心首席架构师）的加入，能明显的感觉到技术文化的一些变化。</p>
<p>数据结构与算法，面试过很多七八年工作经验的人，很少人有能让我满意的（其实离满意差很远，简直难以相信），反而是一些年轻些的朋友，能做得比较好，很多人反驳我说，工作时间长了，这些东西经常不用，就忘了，也可以理解，要求不要太高，差不多行了，确实我也做过一些让步，放低一些要求。但是不得不说这是一种悲哀，数据结构与算法，可以说是整个计算机行业的基础，任何的程序都是构建在这样的基础之上，你告诉我说，随着工作经验的增长，这些基础你忘记了，那我会怀疑我们真的是在同一个行业吗？事实上，如果你不熟悉基础，那你的很多实现就会变得很麻烦，很难理解，耗时很长，而且问题很多。相比之下，国外的公司就很看重这个，好几轮的面试全都是算法，不把 <a href="https://leetcode.com/" target="_blank" rel="noopener"><code>leetcode</code></a> 刷个两三遍，都不好意思去找工作。与其说工作时间长了忘了，不如说是被惯坏了，因为国内这种浮躁的氛围，反正干这行，就肯定能找到工作，此处不留爷自有留爷处，何必花那些时间去折腾那些基础的东西，捞钱才最重要，过个一两年，干不下去了，再换个公司，还能涨比钱，整个行业的整体人才素质，就是这样被拉低了……所以，别和我说你再哪哪哪干过多少年，管过多少个人，在我这不好使，麻烦让我看到，现在此刻你有能力解决这个算法问题。</p>
<p>第三点，至少对一门语言有较深入的研究，至少对一项技术有自己的理解。这个其实挺难的，我看很多简历上都写着，有七八年的 c++ 使用经验，然后竟然不知道标准库里面的排序怎么用，不知道 <code>vector</code> 可以设置 <code>capcity</code>，你……让我情何以堪……，最近在用 golang，虽然用的时间不长，但自以为用得还挺6，但是超哥的加入，让我发现自己对 golang 其实一无所知，单元测试框架，pprof 性能分析，堆栈内存分配机制，锁的性能开销，gc 以及协程调度开销等等，让我开始反思自己到底学了些什么……这里我对语言和技术的定义都比较宽泛，没有特别指定何种语言，哪种技术，因为我觉得技术这东西的思想是相通的，你能掌握好一种，就能很快掌握别的，但是前提是你得掌握至少一种，我看重的是你的学习能力，看过某个牛人说过，『我不是啥都懂，我只是学得快』，如果你一种都不精通，很难让我相信你有很强的学习能力。</p>
<p>第四点，我又强调了一下学习能力，因为这个能力真的很重要，这个行业发展那么迅速，没有很强的学习能力，一定会成为团队的负担。另外沟通表达能力，这个被我之前被我忽视的能力，在最近的一年里，让我有非常深切的体会。这个能力包含两个方面，一个是如何快速准确理解别人给你的信息，还一个是如何准确地传达你想要表达的信息。毕竟这是一个高度社会化的行业，任何事情都是人与人合作的结果，中间任何一点理解上面的偏差都有可能造成非常严重的后果。</p>
<p>第五点，可以说是我个人的一个价值观吧，我从心里欣赏这样的人，希望与这样的人相处，和他们一起共事。最近认识了一些新朋友，都还是学生，已经能在 github 上写出 star 2k+的项目了，在看看自己，感觉很是惭愧……</p>
<p>第六点，特别注明了一下，不接受非本人制作的简历，现在这种找工作的 App 做得都很方便，你在上面随便填写东西，然后就会有猎头找到你，帮你找工作，然后还能自动帮你生成简历，我只想说这种简历实在是太low。简历其实可以看出很多东西，排版组织其实可以看出来你个人的一些性格，对项目的描述，也能看出来你的一些表达能力，当然还有很多细节啦，这种自动生成的东西完全没有太多的参考价值。如果你觉得这个东西很方便，能帮你节约时间的话，那我多少也能看出来，你是一个对自己不负责任，得过且过的人，对自己尚且如此，工作亦然。所以，对自己好一点，做个精致的简历吧！</p>
<p>最后祝大家都能找到自己理想的工作，如果找不到，可以来投奔我😏</p>
]]></content>
      
        
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[与vim的一段往事]]></title>
      <url>/2018/01/21/%E4%B8%8Evim%E7%9A%84%E4%B8%80%E6%AE%B5%E5%BE%80%E4%BA%8B/</url>
      <content type="html"><![CDATA[<p>这就要从大学里面学c语言说起了，那个时候我们还在用古老的 visual c++ 6.0（满满的回忆有木有……），不过我唯一的印象只剩下了，嗯，这个东西真的很丑很难用，不过还好，不久就有了 visual studio 2010，好看是好看了，但是好像卡得不行，也不知道是 windows 的锅呢，还是 vs 的锅呢，还是我电脑配置太低，anyway，这些都不太重要，反正那个时候对 IDE 没有什么好感，再加上英语也不太好，那些软件又都是英文，就更不想用了……</p>
<p>后来呢，进了一个实验室，发现大家都在一个黑白的终端下面写代码，所有的操作都通过键盘完成，完全不用鼠标，当时我都惊呆了，这和电视里面演的黑客不是一模一样么，瞬间觉得那些 IDE 简直 low 爆了，真正厉害的黑客是不用 IDE 的（当时天真的想法……）。Vim —— Text editor of the Gods，正是我想要的。</p>
<p>于是开始读vim的书，查相关的资料，记各种快捷键，装各种插件，折腾我的 vimrc。为了用上更纯粹的 vim，我装了双系统；为我的 chrome 装了 vim 插件；在 win 系统下用 vim 整了一套开发环境。远离鼠标！拒绝 IDE！很快我就在 vim 的使用上面小有成就。</p>
<p>然而一直有一个问题我没有解决，但是我相信和其他问题一样，很快就能找到答案。这个问题就是，我想做到像 IDE 那样的智能代码提示，以及函数的调用以及声明的跳转。我查了好多资料，尝试了很多方案，最后好不容易是有提示了，但是提示的内容只是这个文件中出现的其他标识符，也有点用，但是和我想要的还差很远；然后又继续尝试，功夫不负有心人，终于找到了标准库的代码提示，然而只能提示标准库，我自己写的类并没有用；然后我又继续尝试，然后时间一天天过去，并没有什么进展，渐渐地也就没有太大的兴趣了，现在这么用也挺好，真正的黑客是不依赖 IDE 的提示的。而函数跳转的那个问题也类似，一直也没有找到一个完美的解决方案。</p>
<p>后来开始学 java 了，作为 vim 的脑残粉，肯定是要用 vim 来写 java 的，没有代码提示，没有函数跳转，没有编译调试环境，无形之中给自己增加了好多难度，但是老师可不会等我把这些都整明白了再教，没办法，最终还是很不情愿地随了大流，用了 eclipse。</p>
<p>后来终于毕业了，看到公司里大家都在用 vim，我就放心了，这里这么多大牛，困扰我好几年的问题应该能很快就解决了吧。然而……，我发现，我竟然是这里面用 vim 用得最熟练……，也不知道是该高兴呢，还是该忧伤……</p>
<p>省吃俭用的工资终于够买 Mac，第一件事情，就是配置好 vim。然后果断放弃 windows，开始折腾新的 Mac。发现 Mac 上自带的 xcode 做得还挺好看的，关键是还能写 c++，然后就试了试，感觉还挺爽，关键是有错误直接就能看出来，不像之前用 vim 那样写了一大堆，尝试编译一下，跳出几十个错误；智能提示也很友好，好多之前没用过的函数被提示出来才知道，原来还有这么方便的函数，之前我都用别的方式自己实现了一下……；按住 <code>cmd</code> 键就能很方便地跳转到函数实现的地方，再也不用从一堆文件里面去猜，这个函数可能是在哪里实现的了。尝到甜头之后，开始尝试把公司的项目往 xcode 上面迁，结果开发效率有了极大的提升，而更关键的是写代码变成了一件愉快的事情。</p>
<p>现在，基本我所有的代码都用不同的 IDE（xcode, goland, ideal, pycharm, sublime text 3, webstorm）开发完成。而曾经那么迷恋的 vim，有时候在服务器上写一些临时的脚本，也还是会用一用的。</p>
<p>讲真的，鼠标和 IDE 都是非常伟大的发明，把人从繁复重复无聊的工作中解放出来，让人的精力集中在更具创造力的地方，极大提高了生产效率，推动了整个行业的快速发展。而 vim 作为上一个时代的效率的代表，也曾经那么光彩照人，也是时候功成身退了。</p>
<p>科技在进步，时代在向前，虽然我也是一个怀旧的人，但也不想被潮流甩开太远。</p>
]]></content>
      
        
        <tags>
            
            <tag> vim </tag>
            
            <tag> ide </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[谈谈注释]]></title>
      <url>/2018/01/19/%E8%B0%88%E8%B0%88%E6%B3%A8%E9%87%8A/</url>
      <content type="html"><![CDATA[<p>大家肯定都有写过注释，注释这个东西不同于代码，与程序逻辑的正确性没有直接的关系，所以每个人可能都有自己的风格，每个人对哪里应该写注释，注释应该写成什么样子可能都有自己的理解。</p>
<p>我个人对注释的理解经历了四个阶段。</p>
<p>第一个阶段，完全不写注释，这个阶段还处在代码逻辑的实现上面，花大量的时间去调试，修改代码，根本就无暇顾及到注释这个事情。过了一段时间后，发现之前写的又臭又长的代码完全看不明白了，才意识到注释的重要性，于是开始慢慢进入了第二个阶段。</p>
<p>第二个阶段，哪哪都是注释，每个文件，每个类，每个函数，设置每个分支，每个变量，都有一个注释来说明，就怕漏掉某个小细节然后就看不懂了。后来又发现了一个叫做文档注释的东西（doxygen），这个东西不要太酷，可以根据你的写的注释直接生成文档，于是到处都是文档注释，每个文件里面都有一段简介，而简介里面最重要的内容可能就是 <code>@author: hatlonely</code>，生怕别人不知道这些这么low的代码是你写出来的🤦‍♀️，每个函数参数，函数参数的返回值等等，也都有详尽的注释，注释的长度已经远远超过了代码的长度。看起来好像妈妈再也不用担心我看不懂之前写的代码了，然而，一段时间当我重新读到add这个函数的注释的时候，我发现这些信息对我来说好像并没有用，这段代码已经足够的清晰简单，甚至比注释更容易读懂，那这个注释在这里存在的意义又是什么呢，仅仅是为了生成文档注释吗？而更大的问题可能是，如果我要新增一个函数，<code>add3(int a, int b, int c)</code> 我不得不按照之前的文档注释格式写一大堆的注释……注释的维护也是一个大问题，每次逻辑的变更，都需要去改对应的注释，如果忘记修改，注释和代码逻辑的不一致会让人更加困惑。于是注释的维护变成了一件非常无聊的事情，大大地降低了编程体验，而另一方面冗长繁复的注释也降低了代码的阅读体验。</p>
<pre><code class="c++">// @file: 谈谈注释.md
// @date: 2018-01-19 14:00
// @author: hatlonely
// @brief: 一些对注释的理解

// @brief: 求两个数的和 
// @param a 加数
// @param b 被加数
// @return 和
int add(int a, int b) {
    return a + b;
}
</code></pre>
<p>第三个阶段，代码即注释。突然有一天，看到一个观点，代码是一种艺术，本身就是美，就像是诗歌，你见过一首诗歌里面插入了很多注释吗？注释不是对代码的翻译，而绝大多数时候，你在考虑用一个注释解释一个变量的时候，往往可以通过一个好的变量名来避免这个注释，同样，当你要注释某段逻辑的时候，也往往可以通过优化这段逻辑结构，使用一些可读性更强的变量来描述某些过程。于是我去掉了所有的注释，开始编写可读性更强的代码，开始纠结每一个普通的小变量的命名，开始站在普通人的角度去思考代码的逻辑，让代码更贴近自然语言，把让没有任何计算机基础的人都能读懂我的代码作为目标。于是现在代码看起来清爽了不少，代码本该如此简单。但是我满意了吗？并没有。</p>
<p>第四个阶段，必要的注释。毕竟代码不是诗歌，如果没有当时的文化背景以及别人的解读，大部分是诗歌普通人应该也是读不懂的吧。代码逻辑是由特定的场景决定，同一份代码在不同的场景下面也可能是完全不同的含义，所以为什么会是这样一个逻辑，是这个场景下特定的背景所决定的，而代码本身并不能包含这些背景信息。比如下面这段代码，关于ios过滤的这段逻辑，是因为目前的业务上暂时还没有这个需求决定的，这里的注释给了我们一些额外的信息，对我们理解这段逻辑有很大的帮助，如果没有这段注释，一个月后，你可能也忘记了为什么要有ios这样一个特殊的逻辑，不敢动也不知道，久而久之这些代码就成了谜一样的存在。嗯，看起来很优雅，现在我满意了！</p>
<pre><code class="golang">func checkDeviceType(info DeviceInfo, deviceTypeSet map[int32]struct{}) bool {
    // ios的设备类型不想android那么多，暂时还没有定向需求
    if info.platform != &quot;ios&quot; {
        return true
    }

    if _, ok := deviceTypeSet[info.deviceType]; ok {
        return true
    }
    return false
}
</code></pre>
<p>下一个阶段是什么呢？是时候提高一下自己的表述能力了🤣🤣。</p>
]]></content>
      
        
        <tags>
            
            <tag> 注释 </tag>
            
            <tag> 编码风格 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[golang slice性能分析]]></title>
      <url>/2018/01/18/golang%20slice%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>golang在gc这块的做得比较弱，频繁地申请和释放内存会消耗很多的资源。另外slice使用数组实现，有一个容量和长度的问题，当slice的容量用完再继续添加元素时需要扩容，而这个扩容会把申请新的空间，把老的内容复制到新的空间，这是一个非常耗时的操作。有两种方式可以减少这个问题带来的性能开销：</p>
<ol>
<li>在slice初始化的时候设置capacity（但更多的时候我们可能并不知道capacity的大小）</li>
<li>复用slice</li>
</ol>
<p>下面就针对这两个优化设计了如下的benchmark，代码在: <a href="https://github.com/hatlonely/hellogolang/blob/master/internal/buildin/slice_test.go" target="_blank" rel="noopener">https://github.com/hatlonely/hellogolang/blob/master/internal/buildin/slice_test.go</a></p>
<pre><code>BenchmarkAppendWithoutCapacity-8                     100      21442390 ns/op
BenchmarkAppendWithCapLessLen10th-8                  100      18579700 ns/op
BenchmarkAppendWithCapLessLen3th-8                   100      13867060 ns/op
BenchmarkAppendWithCapEqualLen-8                     200       6287940 ns/op
BenchmarkAppendWithCapGreaterLen10th-8               100      18692880 ns/op
BenchmarkAppendWithoutCapacityReuse-8                300       5014320 ns/op
BenchmarkAppendWithCapEqualLenReuse-8                300       4821420 ns/op
BenchmarkAppendWithCapGreaterLen10thReuse-8          300       4903230 ns/op
</code></pre><p>主要结论：</p>
<ol>
<li>在已知 capacity 的情况下，直接设置 capacity 减少内存的重新分配，有效提高性能</li>
<li>capacity &lt; length，capacity越接近length，性能越好</li>
<li>capacity &gt; lenght，如果太大，反而会造成性能下降，这里当capacity &gt; 10 * length时，与不设置capacity的性能差不太多</li>
<li>多次使用复用同一块内存能有效提高性能</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> golang </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[golang开发目录结构]]></title>
      <url>/2018/01/16/golang%E5%BC%80%E5%8F%91%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>在实际的项目中发现大家的目录结构都比较凌乱，基本每个人都有每个人的风格，一个项目在不断地变大，一些新的文件或目录又不断地被添加进来，从这里面去找到自己需要的信息的成本越来越高，一个统一的通用的目录结构非常有必要。</p>
<p>以下内容来自于github上的这个项目（<a href="https://github.com/golang-standards/project-layout" target="_blank" rel="noopener">https://github.com/golang-standards/project-layout</a>）</p>
<h3 id="cmd"><a href="#cmd" class="headerlink" title="/cmd"></a><code>/cmd</code></h3><p>main函数文件（比如 <code>/cmd/myapp.go</code>）目录，这个目录下面，每个文件在编译之后都会生成一个可执行的文件。</p>
<p>不要把很多的代码放到这个目录下面，这里面的代码尽可能简单。</p>
<h3 id="internal"><a href="#internal" class="headerlink" title="/internal"></a><code>/internal</code></h3><p>应用程序的封装的代码，某个应用私有的代码放到 <code>/internal/myapp/</code> 目录下，多个应用通用的公共的代码，放到 <code>/internal/common</code> 之类的目录。</p>
<h3 id="pkg"><a href="#pkg" class="headerlink" title="/pkg"></a><code>/pkg</code></h3><p>一些通用的可以被其他项目所使用的代码，放到这个目录下面</p>
<h3 id="vendor"><a href="#vendor" class="headerlink" title="/vendor"></a><code>/vendor</code></h3><p>项目依赖的其他第三方库，使用 <a href="https://github.com/Masterminds/glide" target="_blank" rel="noopener"><code>glide</code></a> 工具来管理依赖</p>
<h3 id="api"><a href="#api" class="headerlink" title="/api"></a><code>/api</code></h3><p>协议文件，<code>Swagger/thrift/protobuf</code> 等</p>
<h3 id="web"><a href="#web" class="headerlink" title="/web"></a><code>/web</code></h3><p>web服务所需要的静态文件</p>
<h3 id="configs"><a href="#configs" class="headerlink" title="/configs"></a><code>/configs</code></h3><p>配置文件</p>
<h3 id="init"><a href="#init" class="headerlink" title="/init"></a><code>/init</code></h3><p>服务启停脚本</p>
<h3 id="scripts"><a href="#scripts" class="headerlink" title="/scripts"></a><code>/scripts</code></h3><p>其他一些脚本，编译、安装、测试、分析等等</p>
<h3 id="build"><a href="#build" class="headerlink" title="/build"></a><code>/build</code></h3><p>持续集成目录</p>
<p>云 (AMI), 容器 (Docker), 操作系统 (deb, rpm, pkg)等的包配置和脚本放到 <code>/build/package/</code> 目录</p>
<h3 id="deployments"><a href="#deployments" class="headerlink" title="/deployments"></a><code>/deployments</code></h3><p>部署相关的配置文件和模板</p>
<h3 id="test"><a href="#test" class="headerlink" title="/test"></a><code>/test</code></h3><p>其他测试目录，功能测试，性能测试等</p>
<h3 id="docs"><a href="#docs" class="headerlink" title="/docs"></a><code>/docs</code></h3><p>设计文档</p>
<h3 id="tools"><a href="#tools" class="headerlink" title="/tools"></a><code>/tools</code></h3><p>常用的工具和脚本，可以引用 <code>/internal</code> 或者 <code>/pkg</code> 里面的库</p>
<h3 id="examples"><a href="#examples" class="headerlink" title="/examples"></a><code>/examples</code></h3><p>应用程序或者公共库使用的一些例子</p>
<h3 id="assets"><a href="#assets" class="headerlink" title="/assets"></a><code>/assets</code></h3><p>其他一些依赖的静态资源</p>
]]></content>
      
        
        <tags>
            
            <tag> golang </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《microservice & serverless》by蔡超的一点感想]]></title>
      <url>/2018/01/12/%E3%80%8Amicroservice%20&amp;%20serverless%E3%80%8Bby%E8%94%A1%E8%B6%85%E7%9A%84%E4%B8%80%E7%82%B9%E6%84%9F%E6%83%B3/</url>
      <content type="html"><![CDATA[<p>超哥是来自Amazon的顶级的架构师，经历了Amazon整个向微服务架构迁移的过程，以及向serverless的演化过程，有着极其丰富的经验，年过40，一直站在技术的最前沿，始终保持对技术的执着追求和热情，是名副其实的技术大牛，能与之一起工作，荣幸之至！今天超哥给我们分享的主题《microservice &amp; serverless》，是超哥实际工作经验的一些分享，也为公司架构的演化提供了新的思路和指导。</p>
<p>microservice（微服务）这个可能是这些年最火的一种架构设计了，频繁地出现在各种技术大会上，各大互联网巨头纷纷向这种架构演化，很多小的互联网公司也往这些概念上去靠，大有一种不做微服务就要落伍的趋势。事实上，很多对于微服务的理解比较粗浅，盲目的微服务化甚至会带来更多的负面影响。</p>
<p>目前Amazon内部运行着超过2w过微服务，但是这些微服务并不是凭空产生的，在这之前，运行的服务都是超大的单体服务，但是随着业务的发展，这种服务在整个研发的pipeline（设计→研发→编译→测试→发布→部署→运维）中都出现了一些问题。设计阶段，老的单体服务会给我们带来一些技术限制，比如有些技术只有python语言的实现，但是我们的服务使用java开发，这样我们不得不拿出一个更复杂的设计去解决类似的问题；研发阶段，随着开发人数越来越多，代码冲突的问题越来越多，我们不得不花更多的时间去做这种无趣又没有什么意义的事情；编译阶段，越来越多的依赖很容易造成版本冲突，不同的版本也会引发兼容性的问题，而这种问题如果在运行时才暴露出来可能会造成严重业务影响；部署阶段，很多的特性打包在一起发布，特性越多，出问题的概率也就越大；而最致命的是运维阶段没有回滚方案，一次上线中可能包含很多的特性，而其中任何一条特性的bug就需要回滚，然后可能有些特性需要变更数据格式，新特性能向前兼容老的数据格式，但是回滚后却无法处理新的数据格式，因此无法回滚……就是在这样的背景下，Amazon开始朝微服务的架构演化。</p>
<p>微服务摆脱了单体服务技术的束缚，可以自由地根据业务的特点，选择最适合的技术去实现自己的服务；将一个大的开发流程拆成了很多个小的独立的开发流程，彼此之间不在相互依赖，大大缩短了项目周期；代码冲突的问题也得到了很好的改善；每次发布的特性很少，每天都能发布，而且能做到快速回滚。真正做到，持续集成，持续交付，敏捷开发。</p>
<p>微服务架构同时也带来了一些新的问题。相比与单体服务，微服务的架构数据的传输依赖于rpc的调用，这个调用会带来一些额外的网络耗时，这种耗时往往需要业务上面去考虑是否能容忍，这种rpc的调用收到网络环境的影响，失败是很正常事情，因此需要失败重试机制，于是代码里面到处都充斥着失败重试的冗余代码，影响代码的可读性，更糟糕的是会有雪崩效应，当某个底层服务出现问题时，比如响应时间过长，或者无法访问，这种影响会层层传递到上层，最终导致整个业务系统挂掉；在测试上面也会变得更加困难，之前都在一个实例里面，现在一个服务依赖很多其他的微服务，测试的时候都需要去mock，日志也会分布在不同的服务下面，问题排查比较困难；此外，数据分布在不同的微服务上，在数据一致性上也会有些问题。所以在进行微服务设计的时候也要特别注意这些额外的负面影响，封装重试逻辑，引入熔断和限流机制，统一的日志收集方式。</p>
<p>serverless（无服务器）架构可能是为了让devOps从繁复的运维工作中解放出来的全新架构，最大的特点是整个系统基于AWS提供的各种服务，能够做到自动的拓展以及按流量计费，不再需要人力去维护，大大提高了效率，同时按真实流量的计费对成本也有可能会有优化。而Fass架构，把业务需求封装在一个函数内部，开发人员只需要关注自己的业务逻辑，然后通过网页提交就能完成上线。我在想，当这些技术真正成熟和普及的时候，可能每个普通人，随便花点时间学点python，也能做出一个的服务，而那个时候，我的价值又是什么！？</p>
]]></content>
      
        
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 无服务架构 </tag>
            
            <tag> serverless </tag>
            
            <tag> microservice </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
